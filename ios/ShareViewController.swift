//
//  ShareViewController.swift
//  RNShareMenu
//
//  DO NOT EDIT THIS FILE. IT WILL BE OVERRIDEN BY NPM OR YARN.
//
//  Created by Gustavo Parreira on 26/07/2020.
//  Modified by Ken-ichi Ueda on 15/10/2024.
//  Patched for iOS 18 share-to-app support on 2025/05/12.
//

import UIKit
import Social
import MobileCoreServices
import UniformTypeIdentifiers
import RNShareMenu

// Allows UIApplication.shared in an extension
@available(iOSApplicationExtension, unavailable)
class ShareViewController: SLComposeServiceViewController {
  private var hostAppId: String?
  private var hostAppUrlScheme: String?
  private var sharedItems: [Any] = []

  // MARK: — Lifecycle

  override func viewDidLoad() {
    super.viewDidLoad()
    hostAppId = Bundle.main.object(forInfoDictionaryKey: HOST_APP_IDENTIFIER_INFO_PLIST_KEY) as? String
    hostAppUrlScheme = Bundle.main.object(forInfoDictionaryKey: HOST_URL_SCHEME_INFO_PLIST_KEY) as? String
  }

  override func isContentValid() -> Bool {
    return true
  }

  override func didSelectPost() {
    guard let items = extensionContext?.inputItems as? [NSExtensionItem] else {
      cancelRequest()
      return
    }

    let extraData: [String:Any]? = {
      if let text = contentText, !text.isEmpty {
        return ["userInput": text]
      }
      return nil
    }()

    handlePost(items, extraData: extraData)
  }

  override func configurationItems() -> [SLComposeSheetConfigurationItem]! {
    return []
  }

  // MARK: — Handling Share

  private func handlePost(_ items: [NSExtensionItem], extraData: [String:Any]? = nil) {
    DispatchQueue.global().async {
      guard
        let hostAppId = self.hostAppId,
        let userDefaults = UserDefaults(suiteName: "group.\(hostAppId)")
      else {
        self.cancelRequest()
        return
      }

      // Store or clear extraData
      if let data = extraData {
        userDefaults.set(data, forKey: USER_DEFAULTS_EXTRA_DATA_KEY)
      } else {
        userDefaults.removeObject(forKey: USER_DEFAULTS_EXTRA_DATA_KEY)
      }

      let semaphore = DispatchSemaphore(value: 0)

      for item in items {
        guard let providers = item.attachments else {
          self.cancelRequest()
          return
        }
        for provider in providers {
          if provider.isText {
            self.storeText(withProvider: provider, semaphore)
          } else if provider.isURL {
            self.storeUrl(withProvider: provider, semaphore)
          } else {
            self.storeFile(withProvider: provider, semaphore)
          }
          semaphore.wait()
        }
      }

      // Persist collected items
      userDefaults.set(self.sharedItems, forKey: USER_DEFAULTS_KEY)
      userDefaults.synchronize()

      // Open the host app
      self.openHostApp()
    }
  }

  // MARK: — Store Helpers

  private func storeText(withProvider provider: NSItemProvider, _ semaphore: DispatchSemaphore) {
    provider.loadItem(forTypeIdentifier: kUTTypeText as String, options: nil) { data, error in
      if let error = error {
        self.exit(withError: error.localizedDescription)
        return
      }
      guard let text = data as? String else {
        self.exit(withError: COULD_NOT_FIND_STRING_ERROR)
        return
      }
      self.sharedItems.append([DATA_KEY: text, MIME_TYPE_KEY: "text/plain"])
      semaphore.signal()
    }
  }

  private func storeUrl(withProvider provider: NSItemProvider, _ semaphore: DispatchSemaphore) {
    provider.loadItem(forTypeIdentifier: kUTTypeURL as String, options: nil) { data, error in
      if let error = error {
        self.exit(withError: error.localizedDescription)
        return
      }
      guard let url = data as? URL else {
        self.exit(withError: COULD_NOT_FIND_URL_ERROR)
        return
      }
      self.sharedItems.append([DATA_KEY: url.absoluteString, MIME_TYPE_KEY: "text/plain"])
      semaphore.signal()
    }
  }

  private func storeFile(withProvider provider: NSItemProvider, _ semaphore: DispatchSemaphore) {
    provider.loadItem(forTypeIdentifier: kUTTypeData as String, options: nil) { data, error in
      if let error = error {
        self.exit(withError: error.localizedDescription)
        return
      }
      guard
        let hostAppId = self.hostAppId,
        let groupURL = FileManager.default.containerURL(
          forSecurityApplicationGroupIdentifier: "group.\(hostAppId)"
        )
      else {
        self.exit(withError: NO_APP_GROUP_ERROR)
        return
      }

      if let image = data as? UIImage {
        let filename = "IMG_\(UUID().uuidString).png"
        let dest = groupURL.appendingPathComponent(filename)
        guard let raw = image.pngData(),
              FileManager.default.createFile(atPath: dest.path, contents: raw)
        else {
          self.exit(withError: COULD_NOT_SAVE_FILE_ERROR)
          return
        }
        self.sharedItems.append([
          DATA_KEY: dest.absoluteString,
          MIME_TYPE_KEY: "image/png",
          "fileName": dest.lastPathComponent
        ])
        semaphore.signal()

      } else if let url = data as? URL {
        let filename = "\(UUID().uuidString).\(url.pathExtension)"
        let dest = groupURL.appendingPathComponent(filename)
        do {
          if FileManager.default.fileExists(atPath: dest.path) {
            try FileManager.default.removeItem(at: dest)
          }
          try FileManager.default.copyItem(at: url, to: dest)
          let mime = url.extractMimeType()
          self.sharedItems.append([
            DATA_KEY: dest.absoluteString,
            MIME_TYPE_KEY: mime,
            "fileName": url.lastPathComponent
          ])
          semaphore.signal()
        } catch {
          self.exit(withError: COULD_NOT_SAVE_FILE_ERROR)
        }
      } else {
        self.exit(withError: COULD_NOT_FIND_IMG_ERROR)
      }
    }
  }

  // MARK: — Open Host App

  private func openHostApp() {
    guard
      let scheme = hostAppUrlScheme,
      let url = URL(string: scheme)
    else {
      cancelRequest()
      return
    }
    UIApplication.shared.open(url, options: [:]) { _ in
      self.extensionContext?.completeRequest(returningItems: [], completionHandler: nil)
    }
  }

  // MARK: — Helpers
  private func exit(withError error: String) {
    print("Error: \(error)")
    cancelRequest()
  }

  override func cancelRequest() {
    extensionContext?.cancelRequest(withError: NSError())
  }
}